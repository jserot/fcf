-- AVALON MM-slave wrapper around the core gcd IP
-- Generated by fcfc on 2022-01-08 at 23:36:07 from source file main.fsm

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity gcd_cc is
	port (
		avs_s0_address     : in  std_logic_vector(3 downto 0)  := (others => '0');
        -- 0000 : control/status register (b1=start, b0=rdy)
        -- 0001 : arg1 (a)
        -- 0010 : arg2 (b)
        -- 0011 : res1 (res)
		avs_s0_read        : in  std_logic                     := '0';
		avs_s0_readdata    : out std_logic_vector(31 downto 0);
		avs_s0_write       : in  std_logic                     := '0';
		avs_s0_writedata   : in  std_logic_vector(31 downto 0) := (others => '0');
		clock_clk          : in  std_logic                     := '0';
		reset_reset        : in  std_logic                     := '0'
	);
end entity;


architecture rtl of gcd_cc is

component gcd 
  port(
        start: in std_logic;
        a: in unsigned(15 downto 0);
        b: in unsigned(15 downto 0);
        rdy: out std_logic;
        res: out unsigned(15 downto 0);
        clk: in std_logic;
        rst: in std_logic
);
end component;

  signal start : std_logic;
  signal rdy : std_logic;
  signal a: unsigned(15 downto 0);
  signal b: unsigned(15 downto 0);
  signal res: unsigned(15 downto 0);
  type write_state_t is (Idle, StartAsserted);
  signal write_state: write_state_t;

begin

  GCD_CC : component gcd
		 port map (
          start => start,
          rdy => rdy,
          a => a,
          b => b,
          res => res,
          clk => clock_clk,
          rst => reset_reset
		);

  WRITE: process (clock_clk, reset_reset)
  begin
    if reset_reset = '1' then
      write_state <= Idle;
    elsif rising_edge(clock_clk) then 
      case write_state is
        when StartAsserted =>
          start <= '0';      
          write_state <= Idle;
        when Idle =>
          if avs_s0_write = '1' then
            case avs_s0_address is
              when "0000" =>  -- writing CSR asserts start  for one clock period
                start <= '1';
                write_state <= StartAsserted;
              when "0001" =>
                a <= resize(unsigned(avs_s0_writedata),16);
              when "0010" =>
                b <= resize(unsigned(avs_s0_writedata),16);
              when others =>
                null; 
            end case;
          end if;
      end case;
    end if;
  end process;

  READ: process (clock_clk)
  begin
    if rising_edge(clock_clk) then 
      if avs_s0_read = '1' then
        case avs_s0_address is
          when "0000" => avs_s0_readdata <= "0000000000000000000000000000000" & rdy; -- when reading CSR, bit 0 is rdy
          when "0001" => avs_s0_readdata <= std_logic_vector(resize(a,32));
          when "0010" => avs_s0_readdata <= std_logic_vector(resize(b,32));
          when "0011" => avs_s0_readdata <= std_logic_vector(resize(res,32));
          when others => null; 
        end case;
      end if;
    end if;
  end process;

end architecture;
